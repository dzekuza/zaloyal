{
  "functions": [
    {
      "function_name": "add_project_owner_as_member",
      "function_definition": "CREATE OR REPLACE FUNCTION public.add_project_owner_as_member()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF NEW.id IS NOT NULL AND NEW.owner_id IS NOT NULL THEN\n        INSERT INTO project_members (\n            project_id,\n            user_id,\n            role,\n            permissions,\n            joined_at\n        )\n        VALUES (\n            NEW.id,\n            NEW.owner_id,\n            'owner',\n            ARRAY['view', 'edit', 'create_quests', 'manage_members'],\n            NOW()\n        )\n        ON CONFLICT (project_id, user_id) DO NOTHING;\n    END IF;\n    RETURN NEW;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    IF NEW.id IS NOT NULL AND NEW.owner_id IS NOT NULL THEN\n        INSERT INTO project_members (\n            project_id,\n            user_id,\n            role,\n            permissions,\n            joined_at\n        )\n        VALUES (\n            NEW.id,\n            NEW.owner_id,\n            'owner',\n            ARRAY['view', 'edit', 'create_quests', 'manage_members'],\n            NOW()\n        )\n        ON CONFLICT (project_id, user_id) DO NOTHING;\n    END IF;\n    RETURN NEW;\nEND;\n",
      "description": "Automatically adds project owner as a member with full permissions when a project is created"
    },
    {
      "function_name": "cleanup_old_files",
      "function_definition": "CREATE OR REPLACE FUNCTION public.cleanup_old_files(bucket_id text, days_old integer DEFAULT 30)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    deleted_count INTEGER;\nBEGIN\n    DELETE FROM storage.objects \n    WHERE bucket_id = cleanup_old_files.bucket_id \n    AND created_at < now() - (days_old || ' days')::INTERVAL;\n    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    RETURN deleted_count;\nEND;\n$function$",
      "source_code": "\nDECLARE\n    deleted_count INTEGER;\nBEGIN\n    DELETE FROM storage.objects \n    WHERE bucket_id = cleanup_old_files.bucket_id \n    AND created_at < now() - (days_old || ' days')::INTERVAL;\n    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    RETURN deleted_count;\nEND;\n",
      "description": "Cleans up old files from storage buckets based on age"
    },
    {
      "function_name": "create_user_profile",
      "function_definition": "CREATE OR REPLACE FUNCTION public.create_user_profile()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  INSERT INTO public.users (id, email, username, created_at, updated_at)\n  VALUES (\n    NEW.id,\n    NEW.email,\n    COALESCE(NEW.raw_user_meta_data->>'username', 'user_' || substring(NEW.id::text, 1, 8)),\n    now(),\n    now()\n  )\n  ON CONFLICT (id) DO NOTHING;\n  RETURN NEW;\nEND;\n$function$",
      "source_code": "\nBEGIN\n  INSERT INTO public.users (id, email, username, created_at, updated_at)\n  VALUES (\n    NEW.id,\n    NEW.email,\n    COALESCE(NEW.raw_user_meta_data->>'username', 'user_' || substring(NEW.id::text, 1, 8)),\n    now(),\n    now()\n  )\n  ON CONFLICT (id) DO NOTHING;\n  RETURN NEW;\nEND;\n",
      "description": "Creates a user profile automatically when a new user signs up"
    },
    {
      "function_name": "generate_unique_filename",
      "function_definition": "CREATE OR REPLACE FUNCTION public.generate_unique_filename(original_name text, user_id uuid DEFAULT auth.uid())\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    file_extension TEXT;\n    timestamp TEXT;\n    unique_filename TEXT;\nBEGIN\n    -- Extract file extension\n    file_extension := CASE \n        WHEN original_name LIKE '%.%' THEN \n            '.' || split_part(original_name, '.', -1)\n        ELSE ''\n    END;\n    \n    -- Generate timestamp\n    timestamp := to_char(now(), 'YYYYMMDD_HH24MISS');\n    \n    -- Create unique filename\n    unique_filename := user_id::text || '_' || timestamp || file_extension;\n    \n    RETURN unique_filename;\nEND;\n$function$",
      "source_code": "\nDECLARE\n    file_extension TEXT;\n    timestamp TEXT;\n    unique_filename TEXT;\nBEGIN\n    -- Extract file extension\n    file_extension := CASE \n        WHEN original_name LIKE '%.%' THEN \n            '.' || split_part(original_name, '.', -1)\n        ELSE ''\n    END;\n    \n    -- Generate timestamp\n    timestamp := to_char(now(), 'YYYYMMDD_HH24MISS');\n    \n    -- Create unique filename\n    unique_filename := user_id::text || '_' || timestamp || file_extension;\n    \n    RETURN unique_filename;\nEND;\n",
      "description": "Generates unique filenames for file uploads"
    },
    {
      "function_name": "get_storage_path",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_storage_path(bucket_name text, file_path text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN bucket_name || '/' || file_path;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    RETURN bucket_name || '/' || file_path;\nEND;\n",
      "description": "Helper function to construct storage paths"
    },
    {
      "function_name": "get_storage_stats",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_storage_stats()\n RETURNS TABLE(bucket_id text, file_count bigint, total_size bigint, avg_file_size bigint)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        o.bucket_id,\n        COUNT(*)::BIGINT as file_count,\n        COALESCE(SUM((o.metadata->>'size')::BIGINT), 0) as total_size,\n        COALESCE(AVG((o.metadata->>'size')::BIGINT), 0) as avg_file_size\n    FROM storage.objects o\n    GROUP BY o.bucket_id\n    ORDER BY o.bucket_id;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        o.bucket_id,\n        COUNT(*)::BIGINT as file_count,\n        COALESCE(SUM((o.metadata->>'size')::BIGINT), 0) as total_size,\n        COALESCE(AVG((o.metadata->>'size')::BIGINT), 0) as avg_file_size\n    FROM storage.objects o\n    GROUP BY o.bucket_id\n    ORDER BY o.bucket_id;\nEND;\n",
      "description": "Returns storage statistics for all buckets"
    },
    {
      "function_name": "get_user_by_wallet_address",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_by_wallet_address(p_wallet_address text)\n RETURNS TABLE(user_id uuid, username text, email text, wallet_address text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        u.id,\n        u.username,\n        u.email,\n        u.wallet_address\n    FROM users u\n    WHERE u.wallet_address = p_wallet_address\n    LIMIT 1;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        u.id,\n        u.username,\n        u.email,\n        u.wallet_address\n    FROM users u\n    WHERE u.wallet_address = p_wallet_address\n    LIMIT 1;\nEND;\n",
      "description": "Looks up user by wallet address"
    },
    {
      "function_name": "link_wallet_to_user",
      "function_definition": "CREATE OR REPLACE FUNCTION public.link_wallet_to_user(p_user_id uuid, p_wallet_address text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    existing_user_id UUID;\n    existing_social_account_id UUID;\nBEGIN\n    -- Check if wallet is already linked to another user\n    SELECT user_id INTO existing_user_id\n    FROM social_accounts \n    WHERE platform = 'solana' \n    AND account_id = p_wallet_address\n    AND user_id != p_user_id\n    LIMIT 1;\n    \n    IF existing_user_id IS NOT NULL THEN\n        RAISE EXCEPTION 'Wallet address % is already linked to user %', p_wallet_address, existing_user_id;\n    END IF;\n    \n    -- Check if user already has a wallet linked\n    SELECT id INTO existing_social_account_id\n    FROM social_accounts \n    WHERE user_id = p_user_id \n    AND platform = 'solana'\n    LIMIT 1;\n    \n    -- If user already has a wallet, update it\n    IF existing_social_account_id IS NOT NULL THEN\n        UPDATE social_accounts \n        SET \n            account_id = p_wallet_address,\n            username = substring(p_wallet_address from 1 for 8) || '...',\n            access_token = p_wallet_address,\n            updated_at = NOW()\n        WHERE id = existing_social_account_id;\n    ELSE\n        -- Insert new wallet connection\n        INSERT INTO social_accounts (\n            user_id,\n            platform,\n            account_id,\n            username,\n            access_token,\n            created_at,\n            updated_at\n        ) VALUES (\n            p_user_id,\n            'solana',\n            p_wallet_address,\n            substring(p_wallet_address from 1 for 8) || '...',\n            p_wallet_address,\n            NOW(),\n            NOW()\n        );\n    END IF;\n    \n    -- Update users table wallet_address column\n    UPDATE users \n    SET \n        wallet_address = p_wallet_address,\n        updated_at = NOW()\n    WHERE id = p_user_id;\n    \n    RETURN TRUE;\nEND;\n$function$",
      "source_code": "\nDECLARE\n    existing_user_id UUID;\n    existing_social_account_id UUID;\nBEGIN\n    -- Check if wallet is already linked to another user\n    SELECT user_id INTO existing_user_id\n    FROM social_accounts \n    WHERE platform = 'solana' \n    AND account_id = p_wallet_address\n    AND user_id != p_user_id\n    LIMIT 1;\n    \n    IF existing_user_id IS NOT NULL THEN\n        RAISE EXCEPTION 'Wallet address % is already linked to user %', p_wallet_address, existing_user_id;\n    END IF;\n    \n    -- Check if user already has a wallet linked\n    SELECT id INTO existing_social_account_id\n    FROM social_accounts \n    WHERE user_id = p_user_id \n    AND platform = 'solana'\n    LIMIT 1;\n    \n    -- If user already has a wallet, update it\n    IF existing_social_account_id IS NOT NULL THEN\n        UPDATE social_accounts \n        SET \n            account_id = p_wallet_address,\n            username = substring(p_wallet_address from 1 for 8) || '...',\n            access_token = p_wallet_address,\n            updated_at = NOW()\n        WHERE id = existing_social_account_id;\n    ELSE\n        -- Insert new wallet connection\n        INSERT INTO social_accounts (\n            user_id,\n            platform,\n            account_id,\n            username,\n            access_token,\n            created_at,\n            updated_at\n        ) VALUES (\n            p_user_id,\n            'solana',\n            p_wallet_address,\n            substring(p_wallet_address from 1 for 8) || '...',\n            p_wallet_address,\n            NOW(),\n            NOW()\n        );\n    END IF;\n    \n    -- Update users table wallet_address column\n    UPDATE users \n    SET \n        wallet_address = p_wallet_address,\n        updated_at = NOW()\n    WHERE id = p_user_id;\n    \n    RETURN TRUE;\nEND;\n",
      "description": "Links a wallet address to a user account"
    },
    {
      "function_name": "set_user_role_creator",
      "function_definition": "CREATE OR REPLACE FUNCTION public.set_user_role_creator()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  UPDATE users\n  SET role = 'creator'\n  WHERE id = NEW.owner_id\n    AND role NOT IN ('creator', 'admin');\n  RETURN NEW;\nEND;\n$function$",
      "source_code": "\nBEGIN\n  UPDATE users\n  SET role = 'creator'\n  WHERE id = NEW.owner_id\n    AND role NOT IN ('creator', 'admin');\n  RETURN NEW;\nEND;\n",
      "description": "Sets user role to creator when they create a project"
    },
    {
      "function_name": "store_oauth_state",
      "function_definition": "CREATE OR REPLACE FUNCTION public.store_oauth_state(p_user_id uuid, p_platform text, p_state text, p_code_verifier text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  INSERT INTO oauth_states (user_id, platform, state, code_verifier)\n  VALUES (p_user_id, p_platform, p_state, p_code_verifier)\n  ON CONFLICT (user_id, platform, state) DO UPDATE\n   SET code_verifier = EXCLUDED.code_verifier,\n        created_at = NOW(),\n        expires_at = NOW() + INTERVAL '10 minutes';\nEND;\n$function$",
      "source_code": "\nBEGIN\n  INSERT INTO oauth_states (user_id, platform, state, code_verifier)\n  VALUES (p_user_id, p_platform, p_state, p_code_verifier)\n  ON CONFLICT (user_id, platform, state) DO UPDATE\n   SET code_verifier = EXCLUDED.code_verifier,\n        created_at = NOW(),\n        expires_at = NOW() + INTERVAL '10 minutes';\nEND;\n",
      "description": "Stores OAuth state for social media authentication"
    },
    {
      "function_name": "sync_social_accounts",
      "function_definition": "CREATE OR REPLACE FUNCTION public.sync_social_accounts()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Handle Twitter identities\n    IF NEW.provider = 'twitter' THEN\n        INSERT INTO public.social_accounts (\n            user_id,\n            platform,\n            account_id,\n            username,\n            display_name,\n            access_token,\n            created_at,\n            updated_at\n        )\n        VALUES (\n            NEW.user_id,\n            'twitter',\n            NEW.identity_data->>'sub',\n            NEW.identity_data->>'user_name',\n            NEW.identity_data->>'full_name',\n            NEW.identity_data->>'sub',\n            NEW.created_at,\n            NEW.updated_at\n        )\n        ON CONFLICT (user_id, platform) \n        DO UPDATE SET\n            account_id = EXCLUDED.account_id,\n            username = EXCLUDED.username,\n            display_name = EXCLUDED.display_name,\n            access_token = EXCLUDED.access_token,\n            updated_at = NOW();\n    END IF;\n\n    -- Handle Discord identities\n    IF NEW.provider = 'discord' THEN\n        INSERT INTO public.social_accounts (\n            user_id,\n            platform,\n            account_id,\n            username,\n            display_name,\n            access_token,\n            created_at,\n            updated_at\n        )\n        VALUES (\n            NEW.user_id,\n            'discord',\n            NEW.identity_data->>'sub',\n            NEW.identity_data->>'preferred_username',\n            NEW.identity_data->>'full_name',\n            NEW.identity_data->>'sub',\n            NEW.created_at,\n            NEW.updated_at\n        )\n        ON CONFLICT (user_id, platform) \n        DO UPDATE SET\n            account_id = EXCLUDED.account_id,\n            username = EXCLUDED.username,\n            display_name = EXCLUDED.display_name,\n            access_token = EXCLUDED.access_token,\n            updated_at = NOW();\n    END IF;\n    \n    RETURN NEW;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    -- Handle Twitter identities\n    IF NEW.provider = 'twitter' THEN\n        INSERT INTO public.social_accounts (\n            user_id,\n            platform,\n            account_id,\n            username,\n            display_name,\n            access_token,\n            created_at,\n            updated_at\n        )\n        VALUES (\n            NEW.user_id,\n            'twitter',\n            NEW.identity_data->>'sub',\n            NEW.identity_data->>'user_name',\n            NEW.identity_data->>'full_name',\n            NEW.identity_data->>'sub',\n            NEW.created_at,\n            NEW.updated_at\n        )\n        ON CONFLICT (user_id, platform) \n        DO UPDATE SET\n            account_id = EXCLUDED.account_id,\n            username = EXCLUDED.username,\n            display_name = EXCLUDED.display_name,\n            access_token = EXCLUDED.access_token,\n            updated_at = NOW();\n    END IF;\n\n    -- Handle Discord identities\n    IF NEW.provider = 'discord' THEN\n        INSERT INTO public.social_accounts (\n            user_id,\n            platform,\n            account_id,\n            username,\n            display_name,\n            access_token,\n            created_at,\n            updated_at\n        )\n        VALUES (\n            NEW.user_id,\n            'discord',\n            NEW.identity_data->>'sub',\n            NEW.identity_data->>'preferred_username',\n            NEW.identity_data->>'full_name',\n            NEW.identity_data->>'sub',\n            NEW.created_at,\n            NEW.updated_at\n        )\n        ON CONFLICT (user_id, platform) \n        DO UPDATE SET\n            account_id = EXCLUDED.account_id,\n            username = EXCLUDED.username,\n            display_name = EXCLUDED.display_name,\n            access_token = EXCLUDED.access_token,\n            updated_at = NOW();\n    END IF;\n    \n    RETURN NEW;\nEND;\n",
      "description": "Synchronizes social accounts when users authenticate"
    },
    {
      "function_name": "sync_twitter_to_social_accounts",
      "function_definition": "CREATE OR REPLACE FUNCTION public.sync_twitter_to_social_accounts()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Only process Twitter identities\n    IF NEW.provider = 'twitter' THEN\n        -- Insert or update the social_accounts record\n        INSERT INTO public.social_accounts (\n            user_id,\n            platform,\n            account_id,\n            username,\n            display_name,\n            access_token,\n            created_at,\n            updated_at\n        )\n        VALUES (\n            NEW.user_id,\n            'twitter',\n            NEW.identity_data->>'sub',\n            NEW.identity_data->>'user_name',\n            NEW.identity_data->>'full_name',\n            NEW.identity_data->>'sub', -- Using provider_id as access_token\n            NEW.created_at,\n            NEW.updated_at\n        )\n        ON CONFLICT (user_id, platform) \n        DO UPDATE SET\n            account_id = EXCLUDED.account_id,\n            username = EXCLUDED.username,\n            display_name = EXCLUDED.display_name,\n            access_token = EXCLUDED.access_token,\n            updated_at = NOW();\n    END IF;\n    \n    RETURN NEW;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    -- Only process Twitter identities\n    IF NEW.provider = 'twitter' THEN\n        -- Insert or update the social_accounts record\n        INSERT INTO public.social_accounts (\n            user_id,\n            platform,\n            account_id,\n            username,\n            display_name,\n            access_token,\n            created_at,\n            updated_at\n        )\n        VALUES (\n            NEW.user_id,\n            'twitter',\n            NEW.identity_data->>'sub',\n            NEW.identity_data->>'user_name',\n            NEW.identity_data->>'full_name',\n            NEW.identity_data->>'sub', -- Using provider_id as access_token\n            NEW.created_at,\n            NEW.updated_at\n        )\n        ON CONFLICT (user_id, platform) \n        DO UPDATE SET\n            account_id = EXCLUDED.account_id,\n            username = EXCLUDED.username,\n            display_name = EXCLUDED.display_name,\n            access_token = EXCLUDED.access_token,\n            updated_at = NOW();\n    END IF;\n    \n    RETURN NEW;\nEND;\n",
      "description": "Synchronizes Twitter accounts specifically"
    },
    {
      "function_name": "sync_wallet_address",
      "function_definition": "CREATE OR REPLACE FUNCTION public.sync_wallet_address()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- When a social_account is inserted/updated for solana\n    IF NEW.platform = 'solana' THEN\n        -- Update users table\n        UPDATE users \n        SET \n            wallet_address = NEW.account_id,\n            updated_at = NOW()\n        WHERE id = NEW.user_id;\n    END IF;\n    \n    -- When a social_account is deleted for solana\n    IF TG_OP = 'DELETE' AND OLD.platform = 'solana' THEN\n        -- Clear wallet_address from users table\n        UPDATE users \n        SET \n            wallet_address = NULL,\n            updated_at = NOW()\n        WHERE id = OLD.user_id;\n    END IF;\n    \n    RETURN COALESCE(NEW, OLD);\nEND;\n$function$",
      "source_code": "\nBEGIN\n    -- When a social_account is inserted/updated for solana\n    IF NEW.platform = 'solana' THEN\n        -- Update users table\n        UPDATE users \n        SET \n            wallet_address = NEW.account_id,\n            updated_at = NOW()\n        WHERE id = NEW.user_id;\n    END IF;\n    \n    -- When a social_account is deleted for solana\n    IF TG_OP = 'DELETE' AND OLD.platform = 'solana' THEN\n        -- Clear wallet_address from users table\n        UPDATE users \n        SET \n            wallet_address = NULL,\n            updated_at = NOW()\n        WHERE id = OLD.user_id;\n    END IF;\n    \n    RETURN COALESCE(NEW, OLD);\nEND;\n",
      "description": "Synchronizes wallet addresses between social_accounts and users tables"
    },
    {
      "function_name": "unlink_wallet_from_user",
      "function_definition": "CREATE OR REPLACE FUNCTION public.unlink_wallet_from_user(p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Remove from social_accounts\n    DELETE FROM social_accounts \n    WHERE user_id = p_user_id \n    AND platform = 'solana';\n    \n    -- Clear from users table\n    UPDATE users \n    SET \n        wallet_address = NULL,\n        updated_at = NOW()\n    WHERE id = p_user_id;\n    \n    RETURN TRUE;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    -- Remove from social_accounts\n    DELETE FROM social_accounts \n    WHERE user_id = p_user_id \n    AND platform = 'solana';\n    \n    -- Clear from users table\n    UPDATE users \n    SET \n        wallet_address = NULL,\n        updated_at = NOW()\n    WHERE id = p_user_id;\n    \n    RETURN TRUE;\nEND;\n",
      "description": "Unlinks wallet from user account"
    },
    {
      "function_name": "update_quest_categories_updated_at",
      "function_definition": "CREATE OR REPLACE FUNCTION public.update_quest_categories_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW;\nEND;\n",
      "description": "Updates quest categories timestamp"
    },
    {
      "function_name": "update_user_task_submissions_updated_at",
      "function_definition": "CREATE OR REPLACE FUNCTION public.update_user_task_submissions_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$",
      "source_code": "\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n",
      "description": "Updates user task submissions timestamp"
    },
    {
      "function_name": "validate_file_upload",
      "function_definition": "CREATE OR REPLACE FUNCTION public.validate_file_upload(bucket_id text, file_name text, file_size bigint, mime_type text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    bucket_record RECORD;\nBEGIN\n    -- Get bucket configuration\n    SELECT * INTO bucket_record \n    FROM storage.buckets \n    WHERE id = bucket_id;\n    \n    -- Check if bucket exists\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Bucket % does not exist', bucket_id;\n    END IF;\n    \n    -- Check file size limit\n    IF bucket_record.file_size_limit IS NOT NULL AND file_size > bucket_record.file_size_limit THEN\n        RAISE EXCEPTION 'File size % exceeds limit of %', file_size, bucket_record.file_size_limit;\n    END IF;\n    \n    -- Check MIME type\n    IF bucket_record.allowed_mime_types IS NOT NULL AND NOT (mime_type = ANY(bucket_record.allowed_mime_types)) THEN\n        RAISE EXCEPTION 'MIME type % is not allowed. Allowed types: %', mime_type, bucket_record.allowed_mime_types;\n    END IF;\n    \n    RETURN TRUE;\nEND;\n$function$",
      "source_code": "\nDECLARE\n    bucket_record RECORD;\nBEGIN\n    -- Get bucket configuration\n    SELECT * INTO bucket_record \n    FROM storage.buckets \n    WHERE id = bucket_id;\n    \n    -- Check if bucket exists\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Bucket % does not exist', bucket_id;\n    END IF;\n    \n    -- Check file size limit\n    IF bucket_record.file_size_limit IS NOT NULL AND file_size > bucket_record.file_size_limit THEN\n        RAISE EXCEPTION 'File size % exceeds limit of %', file_size, bucket_record.file_size_limit;\n    END IF;\n    \n    -- Check MIME type\n    IF bucket_record.allowed_mime_types IS NOT NULL AND NOT (mime_type = ANY(bucket_record.allowed_mime_types)) THEN\n        RAISE EXCEPTION 'MIME type % is not allowed. Allowed types: %', mime_type, bucket_record.allowed_mime_types;\n    END IF;\n    \n    RETURN TRUE;\nEND;\n",
      "description": "Validates file uploads against bucket configuration"
    }
  ],
  "metadata": {
    "total_functions": 17,
    "schema": "public",
    "last_updated": "2025-01-27T00:00:00Z",
    "description": "Complete function definitions for the Zaloyal platform database"
  }
} 