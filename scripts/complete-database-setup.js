const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

async function completeDatabaseSetup() {
  console.log('🔧 Complete Database Setup SQL:');
  console.log('⚠️  Please run the following SQL in Supabase SQL Editor:\n');
  
  const setupSQL = [
    "-- ===========================================",
    "-- SOCIAL ACCOUNTS RLS POLICIES",
    "-- ===========================================",
    "",
    "-- Enable RLS on social_accounts table",
    "ALTER TABLE social_accounts ENABLE ROW LEVEL SECURITY;",
    "",
    "-- Drop existing policies if they exist",
    "DROP POLICY IF EXISTS \"Users can view their own social accounts\" ON social_accounts;",
    "DROP POLICY IF EXISTS \"Users can insert their own social accounts\" ON social_accounts;",
    "DROP POLICY IF EXISTS \"Users can update their own social accounts\" ON social_accounts;",
    "DROP POLICY IF EXISTS \"Users can delete their own social accounts\" ON social_accounts;",
    "",
    "-- Create new policies",
    "CREATE POLICY \"Users can view their own social accounts\" ON social_accounts FOR SELECT USING (auth.uid() = user_id);",
    "CREATE POLICY \"Users can insert their own social accounts\" ON social_accounts FOR INSERT WITH CHECK (auth.uid() = user_id);",
    "CREATE POLICY \"Users can update their own social accounts\" ON social_accounts FOR UPDATE USING (auth.uid() = user_id);",
    "CREATE POLICY \"Users can delete their own social accounts\" ON social_accounts FOR DELETE USING (auth.uid() = user_id);",
    "",
    "-- Add unique constraint to prevent duplicate social accounts per user per platform",
    "ALTER TABLE social_accounts ADD CONSTRAINT IF NOT EXISTS social_accounts_user_platform_unique UNIQUE (user_id, platform);",
    "",
    "-- Add indexes for better performance",
    "CREATE INDEX IF NOT EXISTS idx_social_accounts_user_id ON social_accounts(user_id);",
    "CREATE INDEX IF NOT EXISTS idx_social_accounts_platform ON social_accounts(platform);",
    "CREATE INDEX IF NOT EXISTS idx_social_accounts_user_platform ON social_accounts(user_id, platform);",
    "",
    "",
    "-- ===========================================",
    "-- OAUTH STATES TABLE AND FUNCTIONS",
    "-- ===========================================",
    "",
    "-- Create oauth_states table",
    "CREATE TABLE IF NOT EXISTS oauth_states (",
    "  id           uuid PRIMARY KEY DEFAULT gen_random_uuid(),",
    "  user_id      uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,",
    "  platform     text NOT NULL,",
    "  state        text NOT NULL,",
    "  code_verifier text NOT NULL,",
    "  created_at   timestamptz DEFAULT now(),",
    "  expires_at   timestamptz DEFAULT (now() + interval '10 minutes')",
    ");",
    "",
    "-- Enable RLS on oauth_states",
    "ALTER TABLE oauth_states ENABLE ROW LEVEL SECURITY;",
    "",
    "-- Create RLS policies for oauth_states",
    "CREATE POLICY \"Users can view their own oauth states\" ON oauth_states",
    "  FOR SELECT USING (auth.uid() = user_id);",
    "",
    "CREATE POLICY \"Users can insert their own oauth states\" ON oauth_states",
    "  FOR INSERT WITH CHECK (auth.uid() = user_id);",
    "",
    "CREATE POLICY \"Users can delete their own oauth states\" ON oauth_states",
    "  FOR DELETE USING (auth.uid() = user_id);",
    "",
    "-- Add indexes for oauth_states",
    "CREATE INDEX IF NOT EXISTS idx_oauth_states_user_id ON oauth_states(user_id);",
    "CREATE INDEX IF NOT EXISTS idx_oauth_states_state ON oauth_states(state);",
    "CREATE INDEX IF NOT EXISTS idx_oauth_states_expires_at ON oauth_states(expires_at);",
    "",
    "-- Create RPC functions for OAuth state management",
    "CREATE OR REPLACE FUNCTION store_oauth_state(",
    "  p_user_id uuid,",
    "  p_state text,",
    "  p_code_verifier text,",
    "  p_platform text DEFAULT 'x'",
    ")",
    "RETURNS void AS $$",
    "BEGIN",
    "  INSERT INTO oauth_states (user_id, state, code_verifier, platform)",
    "  VALUES (p_user_id, p_state, p_code_verifier, p_platform);",
    "END;",
    "$$ LANGUAGE plpgsql SECURITY DEFINER;",
    "",
    "CREATE OR REPLACE FUNCTION get_oauth_state(",
    "  p_user_id uuid,",
    "  p_state text,",
    "  p_platform text DEFAULT 'x'",
    ")",
    "RETURNS TABLE (",
    "  state text,",
    "  code_verifier text,",
    "  created_at timestamptz,",
    "  expires_at timestamptz",
    ") AS $$",
    "BEGIN",
    "  RETURN QUERY",
    "  SELECT os.state, os.code_verifier, os.created_at, os.expires_at",
    "  FROM oauth_states os",
    "  WHERE os.user_id = p_user_id",
    "    AND os.state = p_state",
    "    AND os.platform = p_platform",
    "    AND os.expires_at > now();",
    "END;",
    "$$ LANGUAGE plpgsql SECURITY DEFINER;",
    "",
    "CREATE OR REPLACE FUNCTION clear_oauth_state(",
    "  p_user_id uuid,",
    "  p_state text,",
    "  p_platform text DEFAULT 'x'",
    ")",
    "RETURNS void AS $$",
    "BEGIN",
    "  DELETE FROM oauth_states",
    "  WHERE user_id = p_user_id",
    "    AND state = p_state",
    "    AND platform = p_platform;",
    "END;",
    "$$ LANGUAGE plpgsql SECURITY DEFINER;",
    "",
    "CREATE OR REPLACE FUNCTION cleanup_expired_oauth_states()",
    "RETURNS void AS $$",
    "BEGIN",
    "  DELETE FROM oauth_states WHERE expires_at < now();",
    "END;",
    "$$ LANGUAGE plpgsql SECURITY DEFINER;",
    "",
    "-- Grant execute permissions",
    "GRANT EXECUTE ON FUNCTION store_oauth_state TO authenticated;",
    "GRANT EXECUTE ON FUNCTION get_oauth_state TO authenticated;",
    "GRANT EXECUTE ON FUNCTION clear_oauth_state TO authenticated;",
    "GRANT EXECUTE ON FUNCTION cleanup_expired_oauth_states TO authenticated;",
    "",
    "",
    "-- ===========================================",
    "-- VERIFICATION RPC FUNCTIONS",
    "-- ===========================================",
    "",
    "-- Create enqueue_verification function",
    "CREATE OR REPLACE FUNCTION enqueue_verification(",
    "  p_task_id uuid,",
    "  p_user_id uuid DEFAULT auth.uid()",
    ")",
    "RETURNS jsonb AS $$",
    "DECLARE",
    "  v_task tasks%ROWTYPE;",
    "  v_social_account social_accounts%ROWTYPE;",
    "  v_existing_verification task_verifications%ROWTYPE;",
    "  v_cache_key text;",
    "  v_cache_result jsonb;",
    "BEGIN",
    "  -- Get task details",
    "  SELECT * INTO v_task FROM tasks WHERE id = p_task_id;",
    "  IF NOT FOUND THEN",
    "    RETURN jsonb_build_object('error', 'Task not found');",
    "  END IF;",
    "",
    "  -- Check if user has linked social account",
    "  SELECT * INTO v_social_account FROM social_accounts WHERE user_id = p_user_id AND platform = 'x';",
    "  IF NOT FOUND THEN",
    "    RETURN jsonb_build_object('error', 'X account not linked');",
    "  END IF;",
    "",
    "  -- Check for existing verification",
    "  SELECT * INTO v_existing_verification FROM task_verifications",
    "  WHERE task_id = p_task_id AND user_id = p_user_id",
    "  ORDER BY created_at DESC LIMIT 1;",
    "",
    "  -- Check cache first",
    "  v_cache_key := p_user_id || ':' || p_task_id || ':' || v_task.social_action;",
    "  SELECT cache_value INTO v_cache_result FROM social_verification_cache",
    "  WHERE cache_key = v_cache_key AND expires_at > now();",
    "",
    "  IF v_cache_result IS NOT NULL THEN",
    "    RETURN jsonb_build_object('status', 'cached', 'result', v_cache_result);",
    "  END IF;",
    "",
    "  -- Insert pending verification",
    "  INSERT INTO task_verifications (user_id, task_id, quest_id, type, status, attempts)",
    "  VALUES (p_user_id, p_task_id, v_task.quest_id, 'x_verification', 'pending', 0);",
    "",
    "  RETURN jsonb_build_object('status', 'pending', 'message', 'Verification queued');",
    "END;",
    "$$ LANGUAGE plpgsql SECURITY DEFINER;",
    "",
    "-- Create get_verification_status function",
    "CREATE OR REPLACE FUNCTION get_verification_status(",
    "  p_task_id uuid,",
    "  p_user_id uuid DEFAULT auth.uid()",
    ")",
    "RETURNS jsonb AS $$",
    "DECLARE",
    "  v_verification task_verifications%ROWTYPE;",
    "BEGIN",
    "  SELECT * INTO v_verification FROM task_verifications",
    "  WHERE task_id = p_task_id AND user_id = p_user_id",
    "  ORDER BY created_at DESC LIMIT 1;",
    "",
    "  IF NOT FOUND THEN",
    "    RETURN jsonb_build_object('status', 'not_found');",
    "  END IF;",
    "",
    "  RETURN jsonb_build_object(",
    "    'status', v_verification.status,",
    "    'result', v_verification.result,",
    "    'attempts', v_verification.attempts,",
    "    'last_attempt', v_verification.last_attempt",
    "  );",
    "END;",
    "$$ LANGUAGE plpgsql SECURITY DEFINER;",
    "",
    "-- Grant execute permissions",
    "GRANT EXECUTE ON FUNCTION enqueue_verification TO authenticated;",
    "GRANT EXECUTE ON FUNCTION get_verification_status TO authenticated;"
  ];

  console.log(setupSQL.join('\n'));
  console.log('\n🎉 Copy and paste the above SQL into your Supabase SQL Editor to complete the database setup!');
  console.log('\n📋 After running this SQL:');
  console.log('1. The social_accounts table will have proper RLS policies');
  console.log('2. The oauth_states table will be created with RLS policies');
  console.log('3. All necessary RPC functions will be created');
  console.log('4. Your X authentication system will be fully functional');
}

completeDatabaseSetup().catch(console.error); 